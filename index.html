<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="pageTitle">永續商店地圖</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        /* ... same styles as before ... */
    </style>
</head>
<body class="antialiased">
    <!-- Fullscreen Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-white z-[9999] flex flex-col items-center justify-center">
        <!-- ... spinner ... -->
    </div>
    
    <!-- Main content structure is the same -->
    <nav>...</nav>
    <section class="hero-section">...</section>
    <section class="search-section">
        <!-- Filter buttons container will be populated dynamically -->
        <div class="flex flex-wrap gap-2" id="filter-buttons-container">
             <button class="tag px-3 py-1 rounded-full text-sm active" data-category="" data-i18n="filterAll"></button>
             <button class="tag px-3 py-1 rounded-full text-sm" data-category="favorites" data-i18n="filterFavorites"></button>
             <!-- Dynamic tags will be inserted here -->
        </div>
    </section>
    <section id="map">...</section>
    <section id="shops">...</section>
    <!-- ... other sections ... -->
    
    <!-- Modals and Toast -->
    <!-- ... all modals are the same ... -->

<script>
document.addEventListener('DOMContentLoaded', () => {
    // ... initial variables are the same ...
    const API_URL = 'https://script.google.com/macros/s/AKfycbzIcS0WXSQV0yNt5lyjvHy7hwDIUItkGeG78T_Yz2mKa83HJMgI9UxsfVIelU6PyKFwkw/exec';
    let allShops = [], policies = {}; // etc.

    // ... translations object remains the same ...
    const translations = { 'zh-TW': { /* ... */ }, 'en': { /* ... */ } };

    // ... showToast, setLanguage are the same ...
    
    async function fetchPublicData() {
        try {
            // ... same fetch logic ...
            const result = await response.json();
            // ... same result handling ...
            allShops = result.data.shops || []; // Now shops will contain a `tags` array of objects
            policies = result.data.policies || {};
            // ...
            setLanguage(currentLang); // This will now call the updated populateFilters
        } catch (error) {
            // ... error handling ...
        } finally {
            document.getElementById('loading-overlay').style.display = 'none';
        }
    }

    const populateFilters = () => {
        const container = document.getElementById('filter-buttons-container');
        // Clear only dynamic tags
        container.querySelectorAll('.tag:not([data-category=""]):not([data-category="favorites"])').forEach(btn => btn.remove());
        
        // Collect all unique tags from all shops
        const allTagsInUse = new Map();
        allShops.forEach(shop => {
            (shop.tags || []).forEach(tag => {
                if (!allTagsInUse.has(tag.id)) {
                    allTagsInUse.set(tag.id, tag);
                }
            });
        });

        // Create buttons from the unique tags
        allTagsInUse.forEach(tag => {
            const tagName = tag[`name_${currentLang}`] || tag['name_zh-TW'];
            const btn = document.createElement('button');
            btn.className = 'tag px-3 py-1 rounded-full text-sm';
            btn.dataset.category = tagName; // Filter by the tag name in the current language
            btn.textContent = tagName;
            container.appendChild(btn);
        });
    };

    const filterAndRender = () => {
        // ... container setup ...
        const filtered = allShops.filter(shop => {
            const name = (shop[`name_${currentLang}`] || shop['name_zh-TW'] || '').toLowerCase();
            const shopTags = (shop.tags || []).map(t => t[`name_${currentLang}`] || t['name_zh-TW']);
            
            // Updated category matching logic
            const categoryMatch = !currentFilterCategory || 
                                  (currentFilterCategory === 'favorites' ? favoriteShops.includes(String(shop.id)) : shopTags.includes(currentFilterCategory));
            
            // Updated search logic to include tags
            const searchMatch = !currentSearchQuery || 
                                name.includes(currentSearchQuery) || 
                                shopTags.some(t => t.toLowerCase().includes(currentSearchQuery));
            
            return categoryMatch && searchMatch;
        });

        // ... rendering logic for toDisplay is largely the same, but the `type` can now be derived from tags ...
        // For simplicity, I'll display the first tag as the "type" on the card.
        toDisplay.forEach(shop => {
            // ...
            const type = (shop.tags && shop.tags[0]) ? (shop.tags[0][`name_${currentLang}`] || shop.tags[0]['name_zh-TW']) : '';
            // The rest of the card HTML generation is the same
        });
        // ...
    };
    
    // ... all other functions (updateMapMarkers, showShopDetail, initMap, event listeners) remain largely the same ...
    
    initMap();
    fetchPublicData();
});
</script>
</body>
</html>
